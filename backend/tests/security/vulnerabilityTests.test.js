const request = require('supertest');
const mongoose = require('mongoose');
const { ethers } = require('ethers');
const app = require('../../server');
const User = require('../../models/User');
const Document = require('../../models/Document');
const jwt = require('jsonwebtoken');

/**
 * Security and penetration testing for common web application vulnerabilities
 */

describe('Security Vulnerability Tests', () => {
  let testUser, testToken;
  let adminUser, adminToken;
  let testDocument;

  beforeAll(async () => {
    // Connect to test database
    const mongoUri = process.env.MONGODB_TEST_URI || 'mongodb://localhost:27017/blockchain-doc-security-test';
    if (mongoose.connection.readyState === 0) {
      await mongoose.connect(mongoUri);
    }
  });

  afterAll(async () => {
    await mongoose.connection.close();
  });

  beforeEach(async () => {
    // Clean up test data
    await User.deleteMany({});
    await Document.deleteMany({});

    // Create test users
    const testWallet = ethers.Wallet.createRandom();
    testUser = await User.create({
      walletAddress: testWallet.address.toLowerCase(),
      role: 'student',
      profile: {
        name: 'Test User',
        email: 'test@example.com'
      },
      permissions: {
        canIssue: false,
        canVerify: true,
        canTransfer: false
      }
    });

    const adminWallet = ethers.Wallet.createRandom();
    adminUser = await User.create({
      walletAddress: adminWallet.address.toLowerCase(),
      role: 'admin',
      profile: {
        name: 'Admin User',
        email: 'admin@example.com'
      },
      permissions: {
        canIssue: true,
        canVerify: true,
        canTransfer: true
      }
    });

    // Generate tokens
    testToken = jwt.sign(
      { userId: testUser._id, walletAddress: testUser.walletAddress, role: testUser.role },
      process.env.JWT_SECRET || 'test-secret'
    );

    adminToken = jwt.sign(
      { userId: adminUser._id, walletAddress: adminUser.walletAddress, role: adminUser.role },
      process.env.JWT_SECRET || 'test-secret'
    );

    // Create test document
    testDocument = await Document.create({
      documentHash: '0x1234567890123456789012345678901234567890123456789012345678901234',
      ipfsHash: 'QmTest123456789012345678901234567890123456789012',
      encryptionKey: 'test-encryption-key',
      metadata: {
        studentName: 'Security Test Student',
        studentId: 'SEC001',
        institutionName: 'Security Test University',
        documentType: 'certificate',
        issueDate: new Date('2023-06-15')
      },
      access: {
        owner: testUser.walletAddress,
        issuer: adminUser.walletAddress,
        authorizedViewers: []
      },
      audit: {
        uploadedBy: adminUser._id
      },
      fileInfo: {
        originalName: 'security-test.pdf',
        mimeType: 'application/pdf',
        size: 1024
      }
    });
  });

  describe('SQL Injection Tests', () => {
    test('should prevent SQL injection in document search', async () => {
      const sqlInjectionPayloads = [
        "'; DROP TABLE documents; --",
        "' OR '1'='1",
        "' UNION SELECT * FROM users --",
        "'; INSERT INTO users (role) VALUES ('admin'); --",
        "' OR 1=1 --",
        "admin'--",
        "admin' /*",
        "' or 1=1#",
        "' or 1=1--",
        "') or '1'='1--",
        "') or ('1'='1--"
      ];

      for (const payload of sqlInjectionPayloads) {
        const response = await request(app)
          .get('/api/documents')
          .set('Authorization', `Bearer ${testToken}`)
          .query({ search: payload })
          .expect(200); // Should not crash, should handle gracefully

        expect(response.body.success).toBe(true);
        // Should not return unauthorized data
        expect(response.body.data).toBeDefined();
      }
    });

    test('should prevent SQL injection in user profile updates', async () => {
      const sqlInjectionPayloads = [
        "'; UPDATE users SET role='admin' WHERE id=1; --",
        "test'; DROP TABLE users; --",
        "' OR '1'='1' --"
      ];

      for (const payload of sqlInjectionPayloads) {
        const response = await request(app)
          .put('/api/users/profile')
          .set('Authorization', `Bearer ${testToken}`)
          .send({
            name: payload,
            email: 'test@example.com'
          });

        // Should either succeed with sanitized input or fail gracefully
        expect([200, 400, 422]).toContain(response.status);
        
        // Verify user role wasn't changed
        const user = await User.findById(testUser._id);
        expect(user.role).toBe('student');
      }
    });
  });

  describe('NoSQL Injection Tests', () => {
    test('should prevent NoSQL injection in authentication', async () => {
      const noSqlInjectionPayloads = [
        { $ne: null },
        { $gt: "" },
        { $regex: ".*" },
        { $where: "this.role === 'admin'" },
        { $or: [{ role: "admin" }, { role: "user" }] }
      ];

      for (const payload of noSqlInjectionPayloads) {
        const response = await request(app)
          .post('/api/auth/nonce')
          .send({
            walletAddress: payload
          })
          .expect(400); // Should reject invalid wallet address format

        expect(response.body.success).toBe(false);
      }
    });

    test('should prevent NoSQL injection in document queries', async () => {
      const noSqlInjectionPayloads = [
        { $ne: null },
        { $gt: "" },
        { $regex: ".*" },
        { $where: "this.access.owner === 'admin'" }
      ];

      for (const payload of noSqlInjectionPayloads) {
        const response = await request(app)
          .get('/api/documents')
          .set('Authorization', `Bearer ${testToken}`)
          .query({ documentType: JSON.stringify(payload) });

        // Should handle gracefully without exposing unauthorized data
        expect([200, 400]).toContain(response.status);
        
        if (response.status === 200) {
          expect(response.body.success).toBe(true);
          // Should not return documents the user doesn't have access to
          if (response.body.data.documents) {
            response.body.data.documents.forEach(doc => {
              expect(
                doc.access.owner === testUser.walletAddress ||
                doc.access.authorizedViewers.includes(testUser.walletAddress) ||
                doc.access.issuer === testUser.walletAddress
              ).toBe(true);
            });
          }
        }
      }
    });
  });

  describe('XSS (Cross-Site Scripting) Tests', () => {
    test('should prevent stored XSS in user profiles', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src="x" onerror="alert(\'XSS\')">',
        '<svg onload="alert(\'XSS\')">',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(\'XSS\')"></iframe>',
        '<body onload="alert(\'XSS\')">',
        '<div onclick="alert(\'XSS\')">Click me</div>',
        '"><script>alert("XSS")</script>',
        '\';alert(String.fromCharCode(88,83,83))//\';alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//--></SCRIPT>">\'><SCRIPT>alert(String.fromCharCode(88,83,83))</SCRIPT>'
      ];

      for (const payload of xssPayloads) {
        const response = await request(app)
          .put('/api/users/profile')
          .set('Authorization', `Bearer ${testToken}`)
          .send({
            name: payload,
            email: 'test@example.com',
            institution: payload
          });

        // Should either succeed with sanitized input or reject
        expect([200, 400, 422]).toContain(response.status);

        // Verify the data was sanitized
        const user = await User.findById(testUser._id);
        if (user.profile.name) {
          expect(user.profile.name).not.toContain('<script>');
          expect(user.profile.name).not.toContain('javascript:');
          expect(user.profile.name).not.toContain('onerror');
          expect(user.profile.name).not.toContain('onload');
        }
      }
    });

    test('should prevent XSS in document metadata', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src="x" onerror="alert(\'XSS\')">',
        'javascript:alert("XSS")'
      ];

      for (const payload of xssPayloads) {
        const testBuffer = Buffer.from('%PDF-1.4\ntest content');
        
        const response = await request(app)
          .post('/api/documents/upload')
          .set('Authorization', `Bearer ${adminToken}`) // Admin can upload
          .attach('document', testBuffer, 'test.pdf')
          .field('studentName', payload)
          .field('studentId', 'XSS001')
          .field('institutionName', payload)
          .field('documentType', 'certificate')
          .field('issueDate', '2023-06-15');

        if (response.status === 201) {
          // If upload succeeded, verify data was sanitized
          const document = await Document.findOne({ 
            'metadata.studentId': 'XSS001' 
          });
          
          if (document) {
            expect(document.metadata.studentName).not.toContain('<script>');
            expect(document.metadata.studentName).not.toContain('javascript:');
            expect(document.metadata.institutionName).not.toContain('<script>');
            expect(document.metadata.institutionName).not.toContain('javascript:');
          }
        }
      }
    });
  });

  describe('CSRF (Cross-Site Request Forgery) Tests', () => {
    test('should require proper authentication for state-changing operations', async () => {
      // Test without CSRF token (if implemented) or without proper authentication
      const response = await request(app)
        .put('/api/users/profile')
        .send({
          name: 'Malicious Update',
          role: 'admin' // Attempt to escalate privileges
        })
        .expect(401); // Should require authentication

      expect(response.body.success).toBe(false);
    });

    test('should validate origin for sensitive operations', async () => {
      // Test with suspicious origin header
      const response = await request(app)
        .post('/api/documents/upload')
        .set('Authorization', `Bearer ${adminToken}`)
        .set('Origin', 'https://malicious-site.com')
        .attach('document', Buffer.from('%PDF-1.4\ntest'), 'test.pdf')
        .field('studentName', 'Test')
        .field('studentId', 'TEST001')
        .field('institutionName', 'Test University')
        .field('documentType', 'certificate')
        .field('issueDate', '2023-06-15');

      // Should either succeed (if origin validation not implemented) or fail
      // The important thing is that it doesn't crash
      expect([200, 201, 403, 400]).toContain(response.status);
    });
  });

  describe('Authentication and Authorization Tests', () => {
    test('should prevent JWT token manipulation', async () => {
      const maliciousTokens = [
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9.invalid',
        testToken.replace(/.$/, 'X'), // Modified signature
        testToken.split('.')[0] + '.eyJyb2xlIjoiYWRtaW4ifQ.' + testToken.split('.')[2], // Modified payload
        'Bearer malicious-token',
        ''
      ];

      for (const maliciousToken of maliciousTokens) {
        const response = await request(app)
          .get('/api/users')
          .set('Authorization', `Bearer ${maliciousToken}`)
          .expect(401);

        expect(response.body.success).toBe(false);
      }
    });

    test('should prevent privilege escalation', async () => {
      // Student trying to access admin endpoint
      const response = await request(app)
        .get('/api/users')
        .set('Authorization', `Bearer ${testToken}`)
        .expect(403);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain('Admin access required');
    });

    test('should prevent unauthorized document access', async () => {
      // Create document owned by admin
      const adminDocument = await Document.create({
        documentHash: '0xadmin567890123456789012345678901234567890123456789012345678901234',
        ipfsHash: 'QmAdmin123456789012345678901234567890123456789012',
        encryptionKey: 'admin-key',
        metadata: {
          studentName: 'Admin Document',
          studentId: 'ADM001',
          institutionName: 'Admin University',
          documentType: 'certificate',
          issueDate: new Date('2023-06-15')
        },
        access: {
          owner: adminUser.walletAddress,
          issuer: adminUser.walletAddress,
          authorizedViewers: [] // Student not authorized
        },
        audit: {
          uploadedBy: adminUser._id
        },
        fileInfo: {
          originalName: 'admin-doc.pdf',
          mimeType: 'application/pdf',
          size: 1024
        }
      });

      // Student trying to access admin's document
      const response = await request(app)
        .get(`/api/documents/${adminDocument.documentHash}`)
        .set('Authorization', `Bearer ${testToken}`)
        .expect(403);

      expect(response.body.success).toBe(false);
    });

    test('should prevent session fixation', async () => {
      // Test that new authentication generates new token
      const wallet = ethers.Wallet.createRandom();
      
      // First authentication
      const nonce1Response = await request(app)
        .post('/api/auth/nonce')
        .send({ walletAddress: wallet.address });

      const signature1 = await wallet.signMessage(nonce1Response.body.data.message);
      
      const auth1Response = await request(app)
        .post('/api/auth/verify')
        .send({
          walletAddress: wallet.address,
          signature: signature1,
          message: nonce1Response.body.data.message
        });

      const token1 = auth1Response.body.data.token;

      // Second authentication
      const nonce2Response = await request(app)
        .post('/api/auth/nonce')
        .send({ walletAddress: wallet.address });

      const signature2 = await wallet.signMessage(nonce2Response.body.data.message);
      
      const auth2Response = await request(app)
        .post('/api/auth/verify')
        .send({
          walletAddress: wallet.address,
          signature: signature2,
          message: nonce2Response.body.data.message
        });

      const token2 = auth2Response.body.data.token;

      // Tokens should be different
      expect(token1).not.toBe(token2);
    });
  });

  describe('Input Validation and Sanitization Tests', () => {
    test('should validate file upload types', async () => {
      const maliciousFiles = [
        { content: '#!/bin/bash\necho "malicious script"', name: 'script.sh', type: 'application/x-sh' },
        { content: '<html><script>alert("xss")</script></html>', name: 'malicious.html', type: 'text/html' },
        { content: 'MZ\x90\x00', name: 'malware.exe', type: 'application/x-msdownload' },
        { content: 'PK\x03\x04', name: 'suspicious.zip', type: 'application/zip' }
      ];

      for (const file of maliciousFiles) {
        const response = await request(app)
          .post('/api/documents/upload')
          .set('Authorization', `Bearer ${adminToken}`)
          .attach('document', Buffer.from(file.content), file.name)
          .field('studentName', 'Test Student')
          .field('studentId', 'TEST001')
          .field('institutionName', 'Test University')
          .field('documentType', 'certificate')
          .field('issueDate', '2023-06-15')
          .expect(400); // Should reject non-PDF files

        expect(response.body.success).toBe(false);
        expect(response.body.message).toContain('not allowed');
      }
    });

    test('should validate file size limits', async () => {
      // Create oversized file (larger than 10MB limit)
      const oversizedBuffer = Buffer.alloc(11 * 1024 * 1024, 'a'); // 11MB

      const response = await request(app)
        .post('/api/documents/upload')
        .set('Authorization', `Bearer ${adminToken}`)
        .attach('document', oversizedBuffer, 'large-file.pdf')
        .field('studentName', 'Test Student')
        .field('studentId', 'TEST001')
        .field('institutionName', 'Test University')
        .field('documentType', 'certificate')
        .field('issueDate', '2023-06-15')
        .expect(413); // Payload too large

      expect(response.body.success).toBe(false);
    });

    test('should validate wallet address format', async () => {
      const invalidAddresses = [
        'invalid-address',
        '0x123', // Too short
        '0x' + 'g'.repeat(40), // Invalid characters
        '123456789012345678901234567890123456789012', // Missing 0x prefix
        '', // Empty
        null,
        undefined
      ];

      for (const address of invalidAddresses) {
        const response = await request(app)
          .post('/api/auth/nonce')
          .send({ walletAddress: address })
          .expect(400);

        expect(response.body.success).toBe(false);
      }
    });

    test('should validate document hash format', async () => {
      const invalidHashes = [
        'invalid-hash',
        '0x123', // Too short
        '0x' + 'g'.repeat(64), // Invalid characters
        '123456789012345678901234567890123456789012345678901234567890123456', // Missing 0x
        '', // Empty
        null
      ];

      for (const hash of invalidHashes) {
        const response = await request(app)
          .get(`/api/documents/${hash}`)
          .set('Authorization', `Bearer ${testToken}`)
          .expect(400);

        expect(response.body.success).toBe(false);
        expect(response.body.message).toContain('Invalid document hash format');
      }
    });
  });

  describe('Rate Limiting Tests', () => {
    test('should rate limit authentication attempts', async () => {
      const wallet = ethers.Wallet.createRandom();
      const promises = [];

      // Make many rapid requests
      for (let i = 0; i < 25; i++) {
        const promise = request(app)
          .post('/api/auth/nonce')
          .send({ walletAddress: wallet.address });
        promises.push(promise);
      }

      const responses = await Promise.all(promises);
      
      // Some should be rate limited
      const rateLimited = responses.filter(r => r.status === 429);
      expect(rateLimited.length).toBeGreaterThan(0);
    });

    test('should rate limit document upload attempts', async () => {
      const promises = [];
      const testBuffer = Buffer.from('%PDF-1.4\ntest');

      // Make many rapid upload attempts
      for (let i = 0; i < 20; i++) {
        const promise = request(app)
          .post('/api/documents/upload')
          .set('Authorization', `Bearer ${adminToken}`)
          .attach('document', testBuffer, `test-${i}.pdf`)
          .field('studentName', `Student ${i}`)
          .field('studentId', `STU${i}`)
          .field('institutionName', 'Test University')
          .field('documentType', 'certificate')
          .field('issueDate', '2023-06-15');
        promises.push(promise);
      }

      const responses = await Promise.all(promises);
      
      // Some should be rate limited or rejected
      const errors = responses.filter(r => r.status >= 400);
      expect(errors.length).toBeGreaterThan(0);
    });
  });

  describe('Information Disclosure Tests', () => {
    test('should not expose sensitive information in error messages', async () => {
      // Test with non-existent document
      const response = await request(app)
        .get('/api/documents/0x9999999999999999999999999999999999999999999999999999999999999999')
        .set('Authorization', `Bearer ${testToken}`)
        .expect(404);

      expect(response.body.success).toBe(false);
      expect(response.body.message).not.toContain('database');
      expect(response.body.message).not.toContain('mongodb');
      expect(response.body.message).not.toContain('collection');
      expect(response.body.message).not.toContain('query');
    });

    test('should not expose stack traces in production', async () => {
      // Force an error by sending malformed data
      const response = await request(app)
        .post('/api/documents/upload')
        .set('Authorization', `Bearer ${adminToken}`)
        .send('malformed-data')
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.stack).toBeUndefined();
      expect(response.body.trace).toBeUndefined();
    });

    test('should not expose user enumeration', async () => {
      const existingWallet = testUser.walletAddress;
      const nonExistentWallet = ethers.Wallet.createRandom().address;

      // Response should be similar for existing and non-existing users
      const response1 = await request(app)
        .post('/api/auth/nonce')
        .send({ walletAddress: existingWallet });

      const response2 = await request(app)
        .post('/api/auth/nonce')
        .send({ walletAddress: nonExistentWallet });

      // Both should succeed (nonce generation creates user if not exists)
      expect(response1.status).toBe(200);
      expect(response2.status).toBe(200);
      
      // Response structure should be similar
      expect(response1.body.success).toBe(response2.body.success);
      expect(typeof response1.body.data.nonce).toBe(typeof response2.body.data.nonce);
    });
  });

  describe('Business Logic Security Tests', () => {
    test('should prevent document ownership manipulation', async () => {
      // Try to upload document claiming different ownership
      const testBuffer = Buffer.from('%PDF-1.4\ntest');
      
      const response = await request(app)
        .post('/api/documents/upload')
        .set('Authorization', `Bearer ${adminToken}`)
        .attach('document', testBuffer, 'test.pdf')
        .field('studentName', 'Test Student')
        .field('studentId', 'TEST001')
        .field('institutionName', 'Test University')
        .field('documentType', 'certificate')
        .field('issueDate', '2023-06-15')
        .field('owner', testUser.walletAddress) // Try to set different owner
        .field('issuer', testUser.walletAddress); // Try to set different issuer

      if (response.status === 201) {
        const document = await Document.findOne({ 'metadata.studentId': 'TEST001' });
        
        // Owner and issuer should be set based on authenticated user, not request data
        expect(document.access.issuer).toBe(adminUser.walletAddress);
        expect(document.audit.uploadedBy.toString()).toBe(adminUser._id.toString());
      }
    });

    test('should prevent role escalation through profile updates', async () => {
      const response = await request(app)
        .put('/api/users/profile')
        .set('Authorization', `Bearer ${testToken}`)
        .send({
          name: 'Updated Name',
          role: 'admin', // Try to escalate to admin
          permissions: {
            canIssue: true,
            canVerify: true,
            canTransfer: true
          }
        });

      // Should either succeed with role unchanged or reject the request
      const user = await User.findById(testUser._id);
      expect(user.role).toBe('student'); // Role should not change
      expect(user.permissions.canIssue).toBe(false); // Permissions should not escalate
    });

    test('should validate document sharing permissions', async () => {
      // Try to share document user doesn't own
      const response = await request(app)
        .post(`/api/documents/${testDocument.documentHash}/share`)
        .set('Authorization', `Bearer ${testToken}`)
        .send({
          walletAddress: adminUser.walletAddress,
          permissions: ['view']
        });

      // Should succeed since testUser owns the document
      if (response.status === 200) {
        // Now try with a user who doesn't own the document
        const unauthorizedUser = await User.create({
          walletAddress: ethers.Wallet.createRandom().address.toLowerCase(),
          role: 'student'
        });

        const unauthorizedToken = jwt.sign(
          { userId: unauthorizedUser._id, walletAddress: unauthorizedUser.walletAddress, role: unauthorizedUser.role },
          process.env.JWT_SECRET || 'test-secret'
        );

        const unauthorizedResponse = await request(app)
          .post(`/api/documents/${testDocument.documentHash}/share`)
          .set('Authorization', `Bearer ${unauthorizedToken}`)
          .send({
            walletAddress: adminUser.walletAddress,
            permissions: ['view']
          })
          .expect(403);

        expect(unauthorizedResponse.body.success).toBe(false);
      }
    });
  });

  describe('Cryptographic Security Tests', () => {
    test('should validate signature authenticity', async () => {
      const wallet1 = ethers.Wallet.createRandom();
      const wallet2 = ethers.Wallet.createRandom();

      // Get nonce for wallet1
      const nonceResponse = await request(app)
        .post('/api/auth/nonce')
        .send({ walletAddress: wallet1.address });

      const message = nonceResponse.body.data.message;
      
      // Sign with wallet2 (wrong wallet)
      const wrongSignature = await wallet2.signMessage(message);

      // Try to authenticate wallet1 with wallet2's signature
      const response = await request(app)
        .post('/api/auth/verify')
        .send({
          walletAddress: wallet1.address,
          signature: wrongSignature,
          message: message
        })
        .expect(401);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain('Invalid signature');
    });

    test('should prevent signature replay attacks', async () => {
      const wallet = ethers.Wallet.createRandom();

      // First authentication
      const nonce1Response = await request(app)
        .post('/api/auth/nonce')
        .send({ walletAddress: wallet.address });

      const signature1 = await wallet.signMessage(nonce1Response.body.data.message);
      
      const auth1Response = await request(app)
        .post('/api/auth/verify')
        .send({
          walletAddress: wallet.address,
          signature: signature1,
          message: nonce1Response.body.data.message
        })
        .expect(200);

      expect(auth1Response.body.success).toBe(true);

      // Try to reuse the same signature
      const replayResponse = await request(app)
        .post('/api/auth/verify')
        .send({
          walletAddress: wallet.address,
          signature: signature1,
          message: nonce1Response.body.data.message
        })
        .expect(401);

      expect(replayResponse.body.success).toBe(false);
      expect(replayResponse.body.message).toContain('Invalid or expired nonce');
    });

    test('should validate message format for signatures', async () => {
      const wallet = ethers.Wallet.createRandom();
      
      // Sign a message with wrong format
      const wrongMessage = 'This is not the correct message format';
      const signature = await wallet.signMessage(wrongMessage);

      const response = await request(app)
        .post('/api/auth/verify')
        .send({
          walletAddress: wallet.address,
          signature: signature,
          message: wrongMessage
        })
        .expect(401);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain('Invalid message format');
    });
  });
});